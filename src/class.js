/**
 * классы явл. основой ООП, но не JS
 *  в JS ООП и наследование основаны на прототипах объектов, а не на классах
 * 
 * в ES6 добавленна поддержка классов
 *  новый синтаксис не вводит новую модель наследования (внутри исп. все теде прототипы)
 *  синтаксис классов это синтаксичекий сахар - упрощающий работу с классами и наследованием в JS
 * 
 * class - это форма(шаблон) по которому создаються объекты,
 *         определяет свойства и методы объекта.
 * * в ES6 class не поднимаеться (hoisting)
 * * в ES5 функции конструкторы засоряют длобальное пространство имен, class в ES6 нет.
 * 
 */

/**
 * классы - это функции кот. создают объекты
 * 
 * Объект - это экземпляр(представитель) класса,
 *          созданный по шаблону с определенными методами и свойствами, указанными в классе
 * 
 * constructor - это особый метод, вызываемый в момент создания объекта с кл.сл. new
 *               создаёт(инициализирут) свойства, может принимать параметры, 
 *               кот. можно будет указать в качесве аргументов, при создании объекта
 * 
 * Свойства - это характеристики объекта, описывающие объект(что у него имееться),
 *            указываются в constructor, т.о. каждый экземпляр класса имеет эти свойства.
 *            * в JS свойства указываються и инициализируется только! в конструкторе 
 *              (этот момент должен быть исправлен в след. версии JS).
 * 
 * Статические свойства - это свойства принадлежащие самому классу, а не объектам, созданным
 *                        созданным на его основе. Часто исп. для хранения вспомогательной информации,
 *                        в отл. от других языков нельзя объявлять статические свойтва, используя кл.сл. static   
 *                
 * Статические методы - это методы принадлежащие самому классу, а не объектам, созданным
 *                        созданным на его основе. Часто исп. для создания вспомогательных функций.  
 * 
 * get & set
 *  у класса, помимо свойств и методов, могут быть Особые свойства: get и ser           
 *  кот. внутри класса выглядят и ведут себя как методы, а снаружи как свойства.
 *  Эти свойства-методы, позволяют получить доступ, и присвоить значения "настоящим" свойствам объекта.
 *  свойство get связывает свойтво объекта с функцией, кот. будет вызываться
 *  при обращении к этому свойству
 *   *отличие get от set - set принимает параметр.
 *   * для использования get и set yне обязательно иметь внутренние свойсва,
 *      тем самым мы получем 'псевдо свойства'
 * 
 *  * у классов (так же как и у объектов в ES6) название свойств и методов 
 *      может быть вычесленно динамически, используя нов. синтаксис []
 */

class Task{
    constructor(title = Task.DEFAULT_TITLE) {
        this.title = title;
        this._done = false;
        Task.count += 1;
        console.info(`Создание задачи: '${this.title }'`)
    };

    get done() {
        return this._done === true ? 'Выполнена' : 'Не выполнена';
    }

    set done(value) {
        if(value !== undefined && typeof value == 'boolean'){
            this._done = value;
        }else{
            console.error('Error: свойсто done принимает true или false');
        }
    }

    complete() {
        this.done = true;
        console.log(`Задача ${this.title} выполнена`);
    }
    // объявление статического метода классу.
    static getDefaultTitle() {
        return 'Задача';
    }
    /**
     * from comments
     *  **вариант - вместо static getDefaultTitle()
     *  **объявление статического свойства классу через гет 
     *      \_ без хуеты с Task.count = 0; после объяявления самого класса.
     */
    static get DEFAULT_TITLE() {
        return "Задача ..deff";
    }

    static get count() {
        if(!this._count) { 
            this._count = 0; 
        };
        return this._count;
    }
    static set count(value) {
        if(value !== undefined && typeof value == 'number'){
            this._count = value;
        }else{
            console.error('Error: свойсто done принимает number');
        }
    }
}
/**
 * объявление статического свойства классу.
 *  \_ с хуетой после объяявления самого класса.
 *  т.к. класс - это функция, а функция - это объект:
 *   после инициализации класса, классу доб. свойство 
 */
Task.count = 0;

let task = new Task('Убрать комноту');
let task2 = new Task('Купить продукты');
let task3 = new Task();

console.log(task);
console.log(task2);
console.log(task3);

task.complete();
console.log(task.done, task._done);

console.log(Task.count);    // Вывод статического свойства класса
console.log(Task.getDefaultTitle()); // Вызов статического методв класса

console.log(typeof Task); // function
console.log(task instanceof Task); // Проверка на принадлежность к классу


